// Package openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package openapi

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	ApiKeyAuthScopes = "ApiKeyAuth.Scopes"
)

// Defines values for HealthResponseStatus.
const (
	HealthResponseStatusHealthy   HealthResponseStatus = "healthy"
	HealthResponseStatusUnhealthy HealthResponseStatus = "unhealthy"
)

// Defines values for RankingResponsePeriodType.
const (
	RankingResponsePeriodTypeMonthly RankingResponsePeriodType = "monthly"
	RankingResponsePeriodTypeWeekly  RankingResponsePeriodType = "weekly"
	RankingResponsePeriodTypeYearly  RankingResponsePeriodType = "yearly"
)

// Defines values for GetArchiveParamsMinUsers.
const (
	GetArchiveParamsMinUsersN10   GetArchiveParamsMinUsers = 10
	GetArchiveParamsMinUsersN100  GetArchiveParamsMinUsers = 100
	GetArchiveParamsMinUsersN1000 GetArchiveParamsMinUsers = 1000
	GetArchiveParamsMinUsersN5    GetArchiveParamsMinUsers = 5
	GetArchiveParamsMinUsersN50   GetArchiveParamsMinUsers = 50
	GetArchiveParamsMinUsersN500  GetArchiveParamsMinUsers = 500
)

// Defines values for SearchEntriesParamsSort.
const (
	SearchEntriesParamsSortHot SearchEntriesParamsSort = "hot"
	SearchEntriesParamsSortNew SearchEntriesParamsSort = "new"
)

// Defines values for GetClickedTagsParamsDays.
const (
	GetClickedTagsParamsDaysN1  GetClickedTagsParamsDays = 1
	GetClickedTagsParamsDaysN30 GetClickedTagsParamsDays = 30
	GetClickedTagsParamsDaysN7  GetClickedTagsParamsDays = 7
)

// Defines values for GetEntriesByTagParamsSort.
const (
	GetEntriesByTagParamsSortHot GetEntriesByTagParamsSort = "hot"
	GetEntriesByTagParamsSortNew GetEntriesByTagParamsSort = "new"
)

// Defines values for GetTrendingTagsParamsHours.
const (
	GetTrendingTagsParamsHoursN12 GetTrendingTagsParamsHours = 12
	GetTrendingTagsParamsHoursN24 GetTrendingTagsParamsHours = 24
	GetTrendingTagsParamsHoursN48 GetTrendingTagsParamsHours = 48
	GetTrendingTagsParamsHoursN6  GetTrendingTagsParamsHours = 6
)

// ApiKeyResponse APIキー発行レスポンス
type ApiKeyResponse struct {
	// CreatedAt 作成日時
	CreatedAt time.Time `json:"created_at"`

	// Description キーの説明
	Description *string `json:"description"`

	// Id APIキーID
	Id openapi_types.UUID `json:"id"`

	// Key 生成されたAPIキー（この1回のみ表示）
	Key string `json:"key"`

	// Name キーの名前
	Name *string `json:"name"`
}

// ArchiveItem 日別エントリー数
type ArchiveItem struct {
	// Count その日のエントリー件数
	Count int `json:"count"`

	// Date 日付（YYYY-MM-DD形式）
	Date openapi_types.Date `json:"date"`
}

// ArchiveResponse 日別エントリー数一覧レスポンス
type ArchiveResponse struct {
	// Items 日別エントリー数一覧（日付降順）
	Items []ArchiveItem `json:"items"`
}

// ClickMetricsRequest クリック計測リクエスト
type ClickMetricsRequest struct {
	// EntryId エントリーID
	EntryId openapi_types.UUID `json:"entry_id"`

	// Referrer リファラーURL（オプション）
	Referrer *string `json:"referrer"`

	// UserAgent ユーザーエージェント（オプション）
	UserAgent *string `json:"user_agent"`
}

// ClickedTag クリックされたタグ（クリック数付き）
type ClickedTag struct {
	// ClickCount 集計期間内でのクリック数
	ClickCount int `json:"click_count"`

	// EntryCount このタグに紐づく総エントリー数
	EntryCount int `json:"entry_count"`

	// Id タグID
	Id openapi_types.UUID `json:"id"`

	// Name タグ名
	Name string `json:"name"`
}

// ClickedTagsResponse クリックされたタグ一覧レスポンス
type ClickedTagsResponse struct {
	// Days 集計対象日数
	Days int `json:"days"`

	// Tags クリックされたタグ一覧
	Tags []ClickedTag `json:"tags"`

	// Total 該当タグ総数
	Total int `json:"total"`
}

// CreateApiKeyRequest APIキー発行リクエスト
type CreateApiKeyRequest struct {
	// Description キーの説明（オプション）
	Description *string `json:"description"`

	// Name キーの名前（オプション、将来の管理用）
	Name *string `json:"name"`
}

// Entry はてなブックマークエントリー
type Entry struct {
	// BookmarkCount はてなブックマーク件数
	BookmarkCount int `json:"bookmark_count"`

	// CreatedAt レコード作成日時（ISO 8601形式）
	CreatedAt time.Time `json:"created_at"`

	// Excerpt 記事本文の抜粋
	Excerpt *string `json:"excerpt"`

	// FaviconUrl Favicon URL（FaviconプロキシAPI）
	FaviconUrl *string `json:"favicon_url,omitempty"`

	// Id エントリーID
	Id openapi_types.UUID `json:"id"`

	// PostedAt 記事の投稿日時（ISO 8601形式）
	PostedAt time.Time `json:"posted_at"`

	// Subject RSSフィードのsubject（画面非表示、内部利用）
	Subject *string `json:"subject"`

	// Tags エントリーに紐づくタグ一覧
	Tags []EntryTag `json:"tags"`

	// Title エントリーのタイトル
	Title string `json:"title"`

	// UpdatedAt レコード更新日時（ISO 8601形式）
	UpdatedAt time.Time `json:"updated_at"`

	// Url エントリーのURL
	Url string `json:"url"`
}

// EntryListResponse エントリー一覧レスポンス
type EntryListResponse struct {
	// Entries エントリー一覧
	Entries []Entry `json:"entries"`

	// Limit 1ページあたりの件数
	Limit int `json:"limit"`

	// Offset オフセット
	Offset int `json:"offset"`

	// Total 総件数（フィルタ適用後）
	Total int `json:"total"`
}

// EntryTag エントリーに紐づくタグ（スコア付き）
type EntryTag struct {
	// Score タグのスコア（Yahoo! キーフレーズ抽出APIから取得した重要度、0〜100）
	Score int `json:"score"`

	// TagId タグID
	TagId openapi_types.UUID `json:"tag_id"`

	// TagName タグ名
	TagName string `json:"tag_name"`
}

// ErrorResponse エラーレスポンス
type ErrorResponse struct {
	// Details 詳細情報（オプション）
	Details *map[string]interface{} `json:"details"`

	// Error エラーコード
	Error string `json:"error"`

	// Message エラーメッセージ
	Message string `json:"message"`
}

// HealthResponse ヘルスチェックレスポンス
type HealthResponse struct {
	// Database データベース接続状態
	Database *struct {
		// Connected 接続可否
		Connected *bool `json:"connected,omitempty"`

		// ResponseTimeMs レスポンスタイム（ミリ秒）
		ResponseTimeMs *float32 `json:"response_time_ms,omitempty"`
	} `json:"database,omitempty"`

	// Status ステータス
	Status HealthResponseStatus `json:"status"`

	// Timestamp チェック実行日時
	Timestamp time.Time `json:"timestamp"`
}

// HealthResponseStatus ステータス
type HealthResponseStatus string

// MetricsResponse メトリクス記録レスポンス
type MetricsResponse struct {
	// Message メッセージ
	Message string `json:"message"`

	// Success 成功フラグ
	Success bool `json:"success"`
}

// RankingEntry ランキングエントリー
type RankingEntry struct {
	// Entry はてなブックマークエントリー
	Entry Entry `json:"entry"`

	// Rank 順位
	Rank int `json:"rank"`
}

// RankingResponse ランキングレスポンス
type RankingResponse struct {
	// Entries ランキングエントリー一覧
	Entries []RankingEntry `json:"entries"`

	// Limit 1ページあたりの件数
	Limit int `json:"limit"`

	// Month 対象月（月次・週次ランキング時のみ）
	Month *int `json:"month"`

	// Offset オフセット
	Offset int `json:"offset"`

	// PeriodType ランキング期間種別
	PeriodType RankingResponsePeriodType `json:"period_type"`

	// Total 対象期間の総エントリー数
	Total int `json:"total"`

	// Week 対象週（週次ランキング時のみ、ISO週番号）
	Week *int `json:"week"`

	// Year 対象年
	Year int `json:"year"`
}

// RankingResponsePeriodType ランキング期間種別
type RankingResponsePeriodType string

// SearchResponse 検索結果レスポンス
type SearchResponse struct {
	// Entries 検索結果のエントリー一覧
	Entries []Entry `json:"entries"`

	// Limit 1ページあたりの件数
	Limit int `json:"limit"`

	// Offset オフセット
	Offset int `json:"offset"`

	// Query 検索キーワード
	Query string `json:"query"`

	// Total 検索結果の総件数
	Total int `json:"total"`
}

// TrendingTag トレンドタグ（出現回数付き）
type TrendingTag struct {
	// EntryCount このタグに紐づく総エントリー数
	EntryCount int `json:"entry_count"`

	// Id タグID
	Id openapi_types.UUID `json:"id"`

	// Name タグ名
	Name string `json:"name"`

	// OccurrenceCount 集計期間内での出現回数（エントリー数）
	OccurrenceCount int `json:"occurrence_count"`
}

// TrendingTagsResponse トレンドタグ一覧レスポンス
type TrendingTagsResponse struct {
	// Hours 集計対象時間
	Hours int `json:"hours"`

	// Tags トレンドタグ一覧
	Tags []TrendingTag `json:"tags"`

	// Total 該当タグ総数
	Total int `json:"total"`
}

// UnauthorizedError エラーレスポンス
type UnauthorizedError = ErrorResponse

// GetArchiveParams defines parameters for GetArchive.
type GetArchiveParams struct {
	// MinUsers 最低ブックマーク件数フィルタ（5, 10, 50, 100, 500, 1000）
	MinUsers *GetArchiveParamsMinUsers `form:"min_users,omitempty" json:"min_users,omitempty"`
}

// GetArchiveParamsMinUsers defines parameters for GetArchive.
type GetArchiveParamsMinUsers int

// GetHotEntriesParams defines parameters for GetHotEntries.
type GetHotEntriesParams struct {
	// Date 取得対象日付（YYYYMMDD形式）
	Date string `form:"date" json:"date"`

	// MinUsers 最低ブックマーク件数（5/10/50/100/500/1000など）
	MinUsers *int `form:"min_users,omitempty" json:"min_users,omitempty"`

	// Limit 取得件数
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset オフセット（ページネーション用）
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetNewEntriesParams defines parameters for GetNewEntries.
type GetNewEntriesParams struct {
	// Date 取得対象日付（YYYYMMDD形式）
	Date string `form:"date" json:"date"`

	// MinUsers 最低ブックマーク件数（5/10/50/100/500/1000など）
	MinUsers *int `form:"min_users,omitempty" json:"min_users,omitempty"`

	// Limit 取得件数
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset オフセット（ページネーション用）
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetFaviconParams defines parameters for GetFavicon.
type GetFaviconParams struct {
	// Domain Faviconを取得するドメイン名
	Domain string `form:"domain" json:"domain"`
}

// GetMonthlyRankingParams defines parameters for GetMonthlyRanking.
type GetMonthlyRankingParams struct {
	// Year 対象年（YYYY形式）
	Year int `form:"year" json:"year"`

	// Month 対象月（MM形式、1-12）
	Month int `form:"month" json:"month"`

	// Limit 取得件数
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset オフセット（ページネーション用）
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetWeeklyRankingParams defines parameters for GetWeeklyRanking.
type GetWeeklyRankingParams struct {
	// Year 対象年（YYYY形式）
	Year int `form:"year" json:"year"`

	// Week 対象週（1-53、ISO週番号）
	Week int `form:"week" json:"week"`

	// Limit 取得件数
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset オフセット（ページネーション用）
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetYearlyRankingParams defines parameters for GetYearlyRanking.
type GetYearlyRankingParams struct {
	// Year 対象年（YYYY形式）
	Year int `form:"year" json:"year"`

	// Limit 取得件数
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset オフセット（ページネーション用）
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// SearchEntriesParams defines parameters for SearchEntries.
type SearchEntriesParams struct {
	// Q 検索キーワード
	Q string `form:"q" json:"q"`

	// MinUsers 最低ブックマーク件数フィルタ
	MinUsers *int `form:"min_users,omitempty" json:"min_users,omitempty"`

	// Sort 並び順（new=新着, hot=人気）
	Sort *SearchEntriesParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// Limit 取得件数
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset オフセット（ページネーション用）
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// SearchEntriesParamsSort defines parameters for SearchEntries.
type SearchEntriesParamsSort string

// GetClickedTagsParams defines parameters for GetClickedTags.
type GetClickedTagsParams struct {
	// Days 集計対象日数（デフォルト 7日間）
	Days *GetClickedTagsParamsDays `form:"days,omitempty" json:"days,omitempty"`

	// Limit 取得件数
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetClickedTagsParamsDays defines parameters for GetClickedTags.
type GetClickedTagsParamsDays int

// GetEntriesByTagParams defines parameters for GetEntriesByTag.
type GetEntriesByTagParams struct {
	// MinUsers 最低ブックマーク件数（5/10/50/100/500/1000など）
	MinUsers *int `form:"min_users,omitempty" json:"min_users,omitempty"`

	// Sort 並び順（new=新着, hot=人気）
	Sort *GetEntriesByTagParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// Limit 取得件数
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset オフセット（ページネーション用）
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetEntriesByTagParamsSort defines parameters for GetEntriesByTag.
type GetEntriesByTagParamsSort string

// GetTrendingTagsParams defines parameters for GetTrendingTags.
type GetTrendingTagsParams struct {
	// Hours 集計対象時間（デフォルト 24時間）
	Hours *GetTrendingTagsParamsHours `form:"hours,omitempty" json:"hours,omitempty"`

	// MinUsers 対象エントリーの最低ブックマーク件数
	MinUsers *int `form:"min_users,omitempty" json:"min_users,omitempty"`

	// Limit 取得件数
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetTrendingTagsParamsHours defines parameters for GetTrendingTags.
type GetTrendingTagsParamsHours int

// CreateApiKeyJSONRequestBody defines body for CreateApiKey for application/json ContentType.
type CreateApiKeyJSONRequestBody = CreateApiKeyRequest

// RecordClickJSONRequestBody defines body for RecordClick for application/json ContentType.
type RecordClickJSONRequestBody = ClickMetricsRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// APIキー発行
	// (POST /api-keys)
	CreateApiKey(w http.ResponseWriter, r *http.Request)
	// 日別エントリー数一覧取得
	// (GET /archive)
	GetArchive(w http.ResponseWriter, r *http.Request, params GetArchiveParams)
	// 人気順エントリー一覧取得
	// (GET /entries/hot)
	GetHotEntries(w http.ResponseWriter, r *http.Request, params GetHotEntriesParams)
	// 新着順エントリー一覧取得
	// (GET /entries/new)
	GetNewEntries(w http.ResponseWriter, r *http.Request, params GetNewEntriesParams)
	// Faviconプロキシ
	// (GET /favicons)
	GetFavicon(w http.ResponseWriter, r *http.Request, params GetFaviconParams)
	// ヘルスチェック
	// (GET /health)
	HealthCheck(w http.ResponseWriter, r *http.Request)
	// クリック計測
	// (POST /metrics/clicks)
	RecordClick(w http.ResponseWriter, r *http.Request)
	// 月次ランキング取得
	// (GET /rankings/monthly)
	GetMonthlyRanking(w http.ResponseWriter, r *http.Request, params GetMonthlyRankingParams)
	// 週次ランキング取得
	// (GET /rankings/weekly)
	GetWeeklyRanking(w http.ResponseWriter, r *http.Request, params GetWeeklyRankingParams)
	// 年次ランキング取得
	// (GET /rankings/yearly)
	GetYearlyRanking(w http.ResponseWriter, r *http.Request, params GetYearlyRankingParams)
	// キーワード検索
	// (GET /search)
	SearchEntries(w http.ResponseWriter, r *http.Request, params SearchEntriesParams)
	// クリックされたエントリーのタグ一覧取得
	// (GET /tags/clicked)
	GetClickedTags(w http.ResponseWriter, r *http.Request, params GetClickedTagsParams)
	// タグ別エントリー一覧取得
	// (GET /tags/entries/{tag})
	GetEntriesByTag(w http.ResponseWriter, r *http.Request, tag string, params GetEntriesByTagParams)
	// トレンドタグ一覧取得
	// (GET /tags/trending)
	GetTrendingTags(w http.ResponseWriter, r *http.Request, params GetTrendingTagsParams)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// APIキー発行
// (POST /api-keys)
func (_ Unimplemented) CreateApiKey(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// 日別エントリー数一覧取得
// (GET /archive)
func (_ Unimplemented) GetArchive(w http.ResponseWriter, r *http.Request, params GetArchiveParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// 人気順エントリー一覧取得
// (GET /entries/hot)
func (_ Unimplemented) GetHotEntries(w http.ResponseWriter, r *http.Request, params GetHotEntriesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// 新着順エントリー一覧取得
// (GET /entries/new)
func (_ Unimplemented) GetNewEntries(w http.ResponseWriter, r *http.Request, params GetNewEntriesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Faviconプロキシ
// (GET /favicons)
func (_ Unimplemented) GetFavicon(w http.ResponseWriter, r *http.Request, params GetFaviconParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ヘルスチェック
// (GET /health)
func (_ Unimplemented) HealthCheck(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// クリック計測
// (POST /metrics/clicks)
func (_ Unimplemented) RecordClick(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// 月次ランキング取得
// (GET /rankings/monthly)
func (_ Unimplemented) GetMonthlyRanking(w http.ResponseWriter, r *http.Request, params GetMonthlyRankingParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// 週次ランキング取得
// (GET /rankings/weekly)
func (_ Unimplemented) GetWeeklyRanking(w http.ResponseWriter, r *http.Request, params GetWeeklyRankingParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// 年次ランキング取得
// (GET /rankings/yearly)
func (_ Unimplemented) GetYearlyRanking(w http.ResponseWriter, r *http.Request, params GetYearlyRankingParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// キーワード検索
// (GET /search)
func (_ Unimplemented) SearchEntries(w http.ResponseWriter, r *http.Request, params SearchEntriesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// クリックされたエントリーのタグ一覧取得
// (GET /tags/clicked)
func (_ Unimplemented) GetClickedTags(w http.ResponseWriter, r *http.Request, params GetClickedTagsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// タグ別エントリー一覧取得
// (GET /tags/entries/{tag})
func (_ Unimplemented) GetEntriesByTag(w http.ResponseWriter, r *http.Request, tag string, params GetEntriesByTagParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// トレンドタグ一覧取得
// (GET /tags/trending)
func (_ Unimplemented) GetTrendingTags(w http.ResponseWriter, r *http.Request, params GetTrendingTagsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// CreateApiKey operation middleware
func (siw *ServerInterfaceWrapper) CreateApiKey(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateApiKey(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetArchive operation middleware
func (siw *ServerInterfaceWrapper) GetArchive(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetArchiveParams

	// ------------- Optional query parameter "min_users" -------------

	err = runtime.BindQueryParameter("form", true, false, "min_users", r.URL.Query(), &params.MinUsers)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "min_users", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetArchive(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetHotEntries operation middleware
func (siw *ServerInterfaceWrapper) GetHotEntries(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetHotEntriesParams

	// ------------- Required query parameter "date" -------------

	if paramValue := r.URL.Query().Get("date"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "date"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "date", r.URL.Query(), &params.Date)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "date", Err: err})
		return
	}

	// ------------- Optional query parameter "min_users" -------------

	err = runtime.BindQueryParameter("form", true, false, "min_users", r.URL.Query(), &params.MinUsers)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "min_users", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetHotEntries(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetNewEntries operation middleware
func (siw *ServerInterfaceWrapper) GetNewEntries(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetNewEntriesParams

	// ------------- Required query parameter "date" -------------

	if paramValue := r.URL.Query().Get("date"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "date"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "date", r.URL.Query(), &params.Date)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "date", Err: err})
		return
	}

	// ------------- Optional query parameter "min_users" -------------

	err = runtime.BindQueryParameter("form", true, false, "min_users", r.URL.Query(), &params.MinUsers)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "min_users", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetNewEntries(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetFavicon operation middleware
func (siw *ServerInterfaceWrapper) GetFavicon(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFaviconParams

	// ------------- Required query parameter "domain" -------------

	if paramValue := r.URL.Query().Get("domain"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "domain"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "domain", r.URL.Query(), &params.Domain)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "domain", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetFavicon(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// HealthCheck operation middleware
func (siw *ServerInterfaceWrapper) HealthCheck(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.HealthCheck(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RecordClick operation middleware
func (siw *ServerInterfaceWrapper) RecordClick(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RecordClick(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetMonthlyRanking operation middleware
func (siw *ServerInterfaceWrapper) GetMonthlyRanking(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetMonthlyRankingParams

	// ------------- Required query parameter "year" -------------

	if paramValue := r.URL.Query().Get("year"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "year"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "year", r.URL.Query(), &params.Year)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "year", Err: err})
		return
	}

	// ------------- Required query parameter "month" -------------

	if paramValue := r.URL.Query().Get("month"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "month"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "month", r.URL.Query(), &params.Month)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "month", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetMonthlyRanking(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetWeeklyRanking operation middleware
func (siw *ServerInterfaceWrapper) GetWeeklyRanking(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetWeeklyRankingParams

	// ------------- Required query parameter "year" -------------

	if paramValue := r.URL.Query().Get("year"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "year"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "year", r.URL.Query(), &params.Year)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "year", Err: err})
		return
	}

	// ------------- Required query parameter "week" -------------

	if paramValue := r.URL.Query().Get("week"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "week"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "week", r.URL.Query(), &params.Week)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "week", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetWeeklyRanking(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetYearlyRanking operation middleware
func (siw *ServerInterfaceWrapper) GetYearlyRanking(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetYearlyRankingParams

	// ------------- Required query parameter "year" -------------

	if paramValue := r.URL.Query().Get("year"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "year"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "year", r.URL.Query(), &params.Year)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "year", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetYearlyRanking(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SearchEntries operation middleware
func (siw *ServerInterfaceWrapper) SearchEntries(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchEntriesParams

	// ------------- Required query parameter "q" -------------

	if paramValue := r.URL.Query().Get("q"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "q"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "q", r.URL.Query(), &params.Q)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "q", Err: err})
		return
	}

	// ------------- Optional query parameter "min_users" -------------

	err = runtime.BindQueryParameter("form", true, false, "min_users", r.URL.Query(), &params.MinUsers)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "min_users", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SearchEntries(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetClickedTags operation middleware
func (siw *ServerInterfaceWrapper) GetClickedTags(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetClickedTagsParams

	// ------------- Optional query parameter "days" -------------

	err = runtime.BindQueryParameter("form", true, false, "days", r.URL.Query(), &params.Days)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "days", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetClickedTags(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetEntriesByTag operation middleware
func (siw *ServerInterfaceWrapper) GetEntriesByTag(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "tag" -------------
	var tag string

	err = runtime.BindStyledParameterWithOptions("simple", "tag", chi.URLParam(r, "tag"), &tag, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tag", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetEntriesByTagParams

	// ------------- Optional query parameter "min_users" -------------

	err = runtime.BindQueryParameter("form", true, false, "min_users", r.URL.Query(), &params.MinUsers)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "min_users", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetEntriesByTag(w, r, tag, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetTrendingTags operation middleware
func (siw *ServerInterfaceWrapper) GetTrendingTags(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTrendingTagsParams

	// ------------- Optional query parameter "hours" -------------

	err = runtime.BindQueryParameter("form", true, false, "hours", r.URL.Query(), &params.Hours)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "hours", Err: err})
		return
	}

	// ------------- Optional query parameter "min_users" -------------

	err = runtime.BindQueryParameter("form", true, false, "min_users", r.URL.Query(), &params.MinUsers)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "min_users", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTrendingTags(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api-keys", wrapper.CreateApiKey)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/archive", wrapper.GetArchive)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/entries/hot", wrapper.GetHotEntries)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/entries/new", wrapper.GetNewEntries)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/favicons", wrapper.GetFavicon)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/health", wrapper.HealthCheck)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/metrics/clicks", wrapper.RecordClick)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/rankings/monthly", wrapper.GetMonthlyRanking)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/rankings/weekly", wrapper.GetWeeklyRanking)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/rankings/yearly", wrapper.GetYearlyRanking)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/search", wrapper.SearchEntries)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/tags/clicked", wrapper.GetClickedTags)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/tags/entries/{tag}", wrapper.GetEntriesByTag)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/tags/trending", wrapper.GetTrendingTags)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AAD//5S3YVcLeQAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
